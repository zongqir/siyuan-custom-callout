# 原生模式光标丢失问题修复文档

## 🎯 问题描述

用户在使用Callout面板选择"原生样式"时，光标会丢失，导致无法继续编辑。这个问题只在选择原生样式时出现，其他Callout类型切换正常。

## 🔍 问题分析

### 问题流程
1. 用户点击"原生样式" → 触发 `handleClearCallout()` 方法
2. 调用 `processor.clearCalloutStyle()` 清除所有callout属性和样式
3. **关键问题**：`hideMenu()` 在100ms后执行，将 `currentTargetBlockQuote` 设为 `null`
4. 导致任何依赖该引用的延迟焦点恢复操作都失效

### 根本原因
- **时序问题**：菜单隐藏速度过快，在光标焦点恢复之前就清空了目标元素引用
- **引用丢失**：`currentTargetBlockQuote` 被提前置空，导致后续焦点操作无效
- **DOM更新延迟**：清除callout样式后，DOM需要时间更新，但光标恢复操作没有等待

## ✅ 修复方案

### 核心思路
在菜单处理层面解决问题，确保光标焦点在菜单隐藏前正确恢复。

### 关键修复点

#### 1. 保存目标引用
```typescript
// 🔧 保存blockquote引用，防止hideMenu时被清空
const targetBlockQuote = this.currentTargetBlockQuote;
```
**作用**：防止 `hideMenu()` 调用时将 `currentTargetBlockQuote` 置空，确保后续操作有效。

#### 2. 优化时序控制
```typescript
setTimeout(() => {
    // 焦点恢复逻辑
}, 250); // 延长等待时间，确保DOM更新完成

setTimeout(() => this.hideMenu(true), 300); // 延迟隐藏菜单
```
**作用**：
- 焦点恢复：250ms，给DOM足够的更新时间
- 菜单隐藏：300ms，确保焦点处理完成后再隐藏

#### 3. 使用requestAnimationFrame确保DOM更新
```typescript
requestAnimationFrame(() => {
    const selection = window.getSelection();
    const range = document.createRange();
    // ... 光标设置逻辑
});
```
**作用**：确保在浏览器下一次重绘前执行，此时DOM已完全更新。

#### 4. 兼容空元素的光标设置
```typescript
if (titleDiv.childNodes.length > 0) {
    range.selectNodeContents(titleDiv);
    range.collapse(false); // 光标移到末尾
} else {
    // 空元素时，确保光标在元素内
    range.selectNodeContents(titleDiv);
}
```
**作用**：无论元素是否有内容，都能正确设置光标位置。

## 🔧 完整修复代码

### 文件：`src/callout/menu.ts`

```typescript
/**
 * 处理清除Callout
 */
private handleClearCallout() {
    if (this.currentTargetBlockQuote) {
        // 🔧 保存blockquote引用，防止hideMenu时被清空
        const targetBlockQuote = this.currentTargetBlockQuote;
        
        this.processor.clearCalloutStyle(targetBlockQuote);
        
        // 🔧 原生模式特殊处理：延迟恢复光标焦点
        setTimeout(() => {
            // 确保光标在正确的位置
            const titleDiv = targetBlockQuote.querySelector('[contenteditable="true"]') as HTMLElement;
            if (titleDiv) {
                console.log('[Callout Menu] 🎯 原生模式：开始恢复光标焦点');
                
                // 强制聚焦并设置光标
                titleDiv.focus();
                
                // 确保光标设置成功
                requestAnimationFrame(() => {
                    const selection = window.getSelection();
                    const range = document.createRange();
                    
                    // 如果titleDiv有内容，光标移到末尾；如果没有内容，也要确保光标在其中
                    if (titleDiv.childNodes.length > 0) {
                        range.selectNodeContents(titleDiv);
                        range.collapse(false); // 光标移到末尾
                    } else {
                        // 空元素时，确保光标在元素内
                        range.selectNodeContents(titleDiv);
                    }
                    
                    selection?.removeAllRanges();
                    selection?.addRange(range);
                    
                    console.log('[Callout Menu] ✅ 原生模式：光标焦点已恢复', {
                        focused: document.activeElement === titleDiv,
                        hasSelection: selection?.rangeCount > 0
                    });
                });
            }
        }, 250); // 延长等待时间，确保DOM更新完成
    }
    
    // 延迟隐藏菜单，确保焦点处理完成
    setTimeout(() => this.hideMenu(true), 300);
}
```

## 🎪 技术要点总结

### 1. 异步操作的时序控制
- **问题**：多个异步操作的执行顺序影响最终效果
- **解决**：合理设置延时，确保操作按正确顺序执行

### 2. DOM引用的生命周期管理
- **问题**：DOM元素引用可能在操作过程中被清空
- **解决**：在关键操作前保存引用，避免引用丢失

### 3. 浏览器渲染机制
- **问题**：DOM修改后浏览器需要时间重绘
- **解决**：使用 `requestAnimationFrame` 确保在重绘后执行

### 4. 焦点和选区管理
- **问题**：元素内容变化后光标位置需要重新设置
- **解决**：使用Selection API精确控制光标位置

## 🧪 测试验证

修复后的行为：
1. ✅ 选择"原生样式"后光标保持在编辑框中
2. ✅ 用户可以立即继续输入
3. ✅ 不影响其他Callout类型的正常切换
4. ✅ 控制台输出调试信息，便于问题追踪

## 📝 经验总结

### 关键经验
1. **先保存，后操作**：在可能影响引用的操作前，先保存关键引用
2. **时序很重要**：异步操作的执行顺序直接影响最终效果
3. **DOM需要时间**：给DOM更新操作足够的缓冲时间
4. **善用浏览器API**：`requestAnimationFrame` 是处理DOM更新时序的利器

### 调试技巧
1. 添加详细的console.log输出，追踪操作流程
2. 检查 `document.activeElement` 确认焦点状态
3. 验证 `selection.rangeCount` 确认选区设置成功

---

**修复完成时间**：2025年10月8日  
**修复范围**：原生模式光标焦点问题  
**影响范围**：仅影响"原生样式"选择，不影响其他功能
