# 🔧 修复 Callout 菜单方框选择问题

## 问题描述

用户报告了两个与Callout菜单相关的BUG：

1. **初始选中位置随机**：打开菜单时，高亮的不是第一个方框（原生样式），而是随机某个方框
2. **方向键移动不正确**：用键盘上下左右移动时，焦点移动方向不符合预期

## 问题分析

### 问题1：鼠标悬停导致"随机"选中

**根本原因**：

在 `src/callout/menu.ts` 的 `createMenuItem` 方法中，每个菜单项都注册了 `mouseenter` 事件监听器：

```typescript
item.addEventListener('mouseenter', () => {
    this.selectedMenuIndex = index;
    this.updateMenuSelection();
});
```

当菜单打开时，如果鼠标碰巧停留在某个方框上，或者用户稍微移动鼠标，就会触发该方框的 `mouseenter` 事件，导致 `selectedMenuIndex` 被修改为鼠标悬停的方框索引。

**用户体验问题**：
- 菜单刚打开，用户还没有任何操作
- 鼠标位置（可能是偶然的）就决定了初始选中的方框
- 看起来像是"随机"选中，实际上是鼠标位置导致的

### 问题2：方向键跨行移动

**根本原因**：

原来的左右方向键实现会跨行移动：

```typescript
// ❌ 旧代码
if (e.key === 'ArrowRight') {
    this.selectedMenuIndex = Math.min(this.selectedMenuIndex + 1, this.menuItems.length - 1);
}
if (e.key === 'ArrowLeft') {
    this.selectedMenuIndex = Math.max(this.selectedMenuIndex - 1, 0);
}
```

**问题场景**：

假设菜单是3列布局（cols=3）：
```
[0] [1] [2]
[3] [4] [5]
[6] [7] [8]
```

如果当前选中 `[2]`（第一行最右边），按右键会移动到 `[3]`（第二行第一个），这不符合网格导航的直觉。

**预期行为**：
- 右键：只在当前行内移动，到行末就停止
- 左键：只在当前行内移动，到行首就停止
- 上下键：跨行移动（这个是正确的）

## 解决方案

### 修复1：延迟启用鼠标悬停

**实现步骤**：

1. 添加控制标志 `allowMouseHover`：

```typescript
// 🔧 控制鼠标悬停是否可以改变选中状态（防止菜单刚打开时鼠标位置干扰）
private allowMouseHover: boolean = false;
```

2. 在 `createMenuItem` 中检查标志：

```typescript
item.addEventListener('mouseenter', () => {
    // 🔧 只有在允许鼠标悬停时才改变选中状态（防止菜单刚打开时的干扰）
    if (this.allowMouseHover) {
        this.selectedMenuIndex = index;
        this.updateMenuSelection();
    }
});
```

3. 在菜单创建时禁用鼠标悬停：

```typescript
createCommandMenu(targetBlockQuote: HTMLElement, isEdit: boolean = false): HTMLElement {
    // ...
    this.selectedMenuIndex = 0;
    this.menuItems = [];
    this.allowMouseHover = false; // 🔧 禁用鼠标悬停，防止初始位置干扰
    // ...
}
```

4. 监听鼠标移动事件，只有在鼠标真正移动后才启用鼠标悬停：

```typescript
showMenu(...) {
    // ...
    this.isMenuVisible = true;
    
    // 🔧 只有在鼠标真正移动后才启用鼠标悬停（而不是简单延迟）
    const enableMouseHoverOnMove = () => {
        this.allowMouseHover = true;
        document.removeEventListener('mousemove', enableMouseHoverOnMove);
    };
    document.addEventListener('mousemove', enableMouseHoverOnMove, { once: true });
}
```

5. 在隐藏菜单时重置标志：

```typescript
hideMenu(immediate: boolean = false) {
    // ...
    this.allowMouseHover = false; // 🔧 重置鼠标悬停标志
}
```

**工作原理**：
- 菜单打开时，`allowMouseHover` 设置为 `false`，禁用鼠标悬停功能
- 同时注册一个全局的 `mousemove` 监听器（仅触发一次）
- 只有当用户**真正移动鼠标**时，才启用鼠标悬停功能
- 如果鼠标静止不动（即使停在某个方框上），也不会触发选中
- 这样既保证了初始选中总是第一个方框，又保留了鼠标悬停的便利性

**优势**：
- 比固定延迟（如300ms）更可靠：即使鼠标静止在方框上，延迟后也不会触发
- 响应更快：用户一移动鼠标就立即启用悬停功能
- 使用 `{ once: true }` 选项，事件监听器自动清理，无内存泄漏

### 修复2：防止方向键跨行

**实现左右键的行内移动**：

```typescript
// ✅ 新代码 - ArrowRight
if (e.key === 'ArrowRight') {
    e.preventDefault();
    // 🔧 修复：向右移动，但不能跨行
    const currentRow = Math.floor(this.selectedMenuIndex / cols);
    const currentCol = this.selectedMenuIndex % cols;
    const nextCol = currentCol + 1;
    
    // 只有在同一行内才移动
    if (nextCol < cols && this.selectedMenuIndex + 1 < this.menuItems.length) {
        const nextRow = Math.floor((this.selectedMenuIndex + 1) / cols);
        // 确保下一个位置仍在同一行
        if (nextRow === currentRow) {
            this.selectedMenuIndex++;
        }
    }
    this.updateMenuSelection();
}

// ✅ 新代码 - ArrowLeft  
if (e.key === 'ArrowLeft') {
    e.preventDefault();
    // 🔧 修复：向左移动，但不能跨行
    const currentCol = this.selectedMenuIndex % cols;
    
    // 只有不在行首才移动
    if (currentCol > 0) {
        this.selectedMenuIndex--;
    }
    this.updateMenuSelection();
}
```

**工作原理**：

对于3列布局（cols=3）：
```
[0] [1] [2]   ← 第0行：索引0-2
[3] [4] [5]   ← 第1行：索引3-5
[6] [7] [8]   ← 第2行：索引6-8
```

- **ArrowRight**：
  - 计算当前行号和列号
  - 检查下一个位置是否在同一行
  - 只有在同一行时才移动
  - 例如：从[2]按右键，检测到[3]在不同行，不移动

- **ArrowLeft**：
  - 计算当前列号（索引 % cols）
  - 只有不在第0列时才能向左移动
  - 例如：从[3]按左键，检测到在第0列，不移动

- **ArrowUp/ArrowDown**：保持原有逻辑（加减cols），可以正常跨行移动

## 测试场景

### 测试1：初始选中

1. 打开Callout菜单
2. 验证：第一个方框（"原生样式"）应该被高亮
3. 重复打开关闭菜单多次，每次都应该选中第一个方框

### 测试2：鼠标悬停控制

1. **静止鼠标测试**：
   - 鼠标停在某个位置
   - 打开菜单（确保某个方框在鼠标下方）
   - 验证：第一个方框应该被高亮，不会被鼠标位置影响
   - 保持鼠标静止，第一个方框应该始终保持高亮

2. **移动鼠标测试**：
   - 打开菜单
   - 移动鼠标到其他方框上
   - 验证：鼠标移动后，悬停的方框应该立即被高亮

### 测试3：方向键导航（3列布局）

假设菜单布局：
```
[原生] [信息] [技巧]
[权衡] [说明] [实践]
[深潜] [陷阱] [分析]
[总结]
```

测试步骤：

1. **右键测试**：
   - 从[原生]按右键 → 应移动到[信息]
   - 从[技巧]按右键 → 应停在[技巧]（不跨行）
   - 从[实践]按右键 → 应停在[实践]（不跨行）

2. **左键测试**：
   - 从[技巧]按左键 → 应移动到[信息]
   - 从[原生]按左键 → 应停在[原生]（不跨行）
   - 从[权衡]按左键 → 应停在[权衡]（不跨行）

3. **下键测试**：
   - 从[原生]按下键 → 应移动到[权衡]
   - 从[深潜]按下键 → 应移动到[总结]
   - 从[总结]按下键 → 应停在[总结]（没有更多行）

4. **上键测试**：
   - 从[总结]按上键 → 应移动到[深潜]
   - 从[权衡]按上键 → 应移动到[原生]
   - 从[原生]按上键 → 应停在[原生]（没有更多行）

### 测试4：组合导航

1. 打开菜单（选中[原生]）
2. 按下键 → [权衡]
3. 按右键 → [说明]
4. 按上键 → [信息]
5. 按右键 → [技巧]
6. 按右键 → 停在[技巧]（行末）

## 修改文件

- **src/callout/menu.ts**

### 相关代码行

- 第37行：添加 `allowMouseHover` 标志
- 第88行：初始化时禁用鼠标悬停
- 第297-303行：mouseenter事件中检查标志
- 第383-431行：修正方向键导航逻辑
- 第926-931行：监听鼠标移动事件，只有在鼠标移动后才启用悬停
- 第950行：隐藏菜单时重置标志

## 版本信息

- **修复日期**：2025-10-09
- **修复版本**：v1.2.2
- **影响版本**：v1.2.1 及更早版本

## 后续优化建议

1. **可配置的延迟时间**：300ms可能需要根据用户反馈调整
2. **动画效果**：可以在方向键移动时添加平滑过渡动画
3. **循环导航**：可选地支持在行末按右键跳到下一行行首（类似TAB键）
4. **Page Up/Down支持**：快速跳转到第一个/最后一个方框

